<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.1.0.

Copyright 1991, 1993-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in GNU Free Documentation License. -->
<title>Transcendental Functions (GNU MPFR 4.1.0)</title>

<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 4.1.0.">
<meta name="keywords" content="Transcendental Functions (GNU MPFR 4.1.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="MPFR-Interface.html" rel="up" title="MPFR Interface">
<link href="Input-and-Output-Functions.html" rel="next" title="Input and Output Functions">
<link href="Comparison-Functions.html" rel="prev" title="Comparison Functions">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Transcendental-Functions">
<div class="header">
<p>
Next: <a href="Input-and-Output-Functions.html" accesskey="n" rel="next">Input and Output Functions</a>, Previous: <a href="Comparison-Functions.html" accesskey="p" rel="prev">Comparison Functions</a>, Up: <a href="MPFR-Interface.html" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="index-Transcendental-functions"></span>
<span id="Transcendental-Functions-1"></span><h3 class="section">5.7 Transcendental Functions</h3>

<p>All those functions, except explicitly stated (for example
<code>mpfr_sin_cos</code>), return a <a href="Rounding.html#ternary-value">ternary value</a>, i.e., zero for an
exact return value, a positive value for a return value larger than the
exact result, and a negative value otherwise.
</p>
<p>Important note: In some domains, computing transcendental functions
(even more with correct rounding) is expensive, even in small precision,
for example the trigonometric and Bessel functions with a large argument.
For some functions, the algorithm complexity and memory usage does not
depend only on the output precision: for instance, the memory usage of
<code>mpfr_rootn_ui</code> is also linear in the argument <var>k</var>, and the
memory usage of the incomplete Gamma function also depends on the
precision of the input <var>op</var>. It is also theoretically possible that
some functions on some particular inputs might be very hard to round
(i.e. the Table Maker&rsquo;s Dilemma occurs in much larger precisions than
normally expected from the context), meaning that the internal precision
needs to be increased even more; but it is conjectured that the needed
precision has a reasonable bound.
</p>
<dl class="def">
<dt id="index-mpfr_005flog"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_log</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flog' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005flog_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_log_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flog_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005flog2"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_log2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flog2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005flog10"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_log10</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flog10' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the natural logarithm of <var>op</var>,
<em class='math'>log2(<var>op</var>)</em> or
<em class='math'>log10(<var>op</var>)</em>, respectively,
rounded in the direction <var>rnd</var>.
Set <var>rop</var> to +0 if <var>op</var> is 1 (in all rounding modes),
for consistency with the ISO C99 and IEEE&nbsp;754-2008 standards.
Set <var>rop</var> to −Inf if <var>op</var> is ±0
(i.e., the sign of the zero has no influence on the result).
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005flog1p"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_log1p</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flog1p' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the logarithm of one plus <var>op</var>,
rounded in the direction <var>rnd</var>.
Set <var>rop</var> to −Inf if <var>op</var> is −1.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fexp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_exp</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fexp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fexp2"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_exp2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fexp2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fexp10"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_exp10</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fexp10' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the exponential of <var>op</var>,
 to <em class='math'>2 power of <var>op</var></em>
or to <em class='math'>10 power of <var>op</var></em>, respectively,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fexpm1"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_expm1</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fexpm1' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>the exponential of <var>op</var> followed by a
subtraction by one</em>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<span id="mpfr_005fpow"></span><dl class="def">
<dt id="index-mpfr_005fpow"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_pow</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fpow' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fpow_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_pow_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fpow_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fpow_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_pow_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fpow_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fpow_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_pow_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fpow_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fui_005fpow_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_ui_pow_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fui_005fpow_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fui_005fpow"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_ui_pow</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fui_005fpow' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var> raised to <var>op2</var></em>,
rounded in the direction <var>rnd</var>.
Special values are handled as described in the ISO C99 and IEEE&nbsp;754-2008
standards for the <code>pow</code> function:
</p><ul>
<li> <code>pow(±0, <var>y</var>)</code> returns plus or minus infinity for <var>y</var> a negative odd integer.
</li><li> <code>pow(±0, <var>y</var>)</code> returns plus infinity for <var>y</var> negative and not an odd integer.
</li><li> <code>pow(±0, <var>y</var>)</code> returns plus or minus zero for <var>y</var> a positive odd integer.
</li><li> <code>pow(±0, <var>y</var>)</code> returns plus zero for <var>y</var> positive and not an odd integer.
</li><li> <code>pow(-1, ±Inf)</code> returns 1.
</li><li> <code>pow(+1, <var>y</var>)</code> returns 1 for any <var>y</var>, even a NaN.
</li><li> <code>pow(<var>x</var>, ±0)</code> returns 1 for any <var>x</var>, even a NaN.
</li><li> <code>pow(<var>x</var>, <var>y</var>)</code> returns NaN for finite negative <var>x</var> and finite non-integer <var>y</var>.
</li><li> <code>pow(<var>x</var>, -Inf)</code> returns plus infinity for <em class='math'>0 &lt; abs(x) &lt; 1</em>, and plus zero for <em class='math'>abs(x) &gt; 1</em>.
</li><li> <code>pow(<var>x</var>, +Inf)</code> returns plus zero for <em class='math'>0 &lt; abs(x) &lt; 1</em>, and plus infinity for <em class='math'>abs(x) &gt; 1</em>.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns minus zero for <var>y</var> a negative odd integer.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns plus zero for <var>y</var> negative and not an odd integer.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns minus infinity for <var>y</var> a positive odd integer.
</li><li> <code>pow(-Inf, <var>y</var>)</code> returns plus infinity for <var>y</var> positive and not an odd integer.
</li><li> <code>pow(+Inf, <var>y</var>)</code> returns plus zero for <var>y</var> negative, and plus infinity for <var>y</var> positive.
</li></ul>
<p>Note: When 0 is of integer type, it is regarded as +0 by these functions.
We do not use the usual limit rules in this case, as these rules are not
used for <code>pow</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fcos"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_cos</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcos' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsin"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sin</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsin' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ftan"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_tan</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ftan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the cosine of <var>op</var>, sine of <var>op</var>,
tangent of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsin_005fcos"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sin_cos</strong> <em>(mpfr_t <var>sop</var>, mpfr_t <var>cop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsin_005fcos' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set simultaneously <var>sop</var> to the sine of <var>op</var> and <var>cop</var> to the
cosine of <var>op</var>, rounded in the direction <var>rnd</var> with the corresponding
precisions of <var>sop</var> and <var>cop</var>, which must be different variables.
Return 0 iff both results are exact, more precisely it returns <em class='math'>s+4c</em>
where <em class='math'>s=0</em> if <var>sop</var> is exact, <em class='math'>s=1</em> if <var>sop</var> is larger
than the sine of <var>op</var>, <em class='math'>s=2</em> if <var>sop</var> is smaller than the sine
of <var>op</var>, and similarly for <em class='math'>c</em> and the cosine of <var>op</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsec"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sec</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsec' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fcsc"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_csc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcsc' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fcot"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_cot</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcot' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the secant of <var>op</var>, cosecant of <var>op</var>,
cotangent of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005facos"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_acos</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005facos' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fasin"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_asin</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fasin' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fatan"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_atan</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fatan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the arc-cosine, arc-sine or arc-tangent of <var>op</var>,
rounded in the direction <var>rnd</var>.
Note that since <code>acos(-1)</code> returns the floating-point number closest to
<em class='math'>Pi</em> according to the given rounding mode, this number might not be
in the output range <em class='math'>0 &lt;= <var>rop</var> &lt; Pi</em>
of the arc-cosine function;
still, the result lies in the image of the output range
by the rounding function.
The same holds for <code>asin(-1)</code>, <code>asin(1)</code>, <code>atan(-Inf)</code>,
<code>atan(+Inf)</code> or for <code>atan(op)</code> with large <var>op</var> and
small precision of <var>rop</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fatan2"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_atan2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>y</var>, mpfr_t <var>x</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fatan2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the arc-tangent2 of <var>y</var> and <var>x</var>,
rounded in the direction <var>rnd</var>:
if <code>x &gt; 0</code>, <code>atan2(y, x) = atan(y/x)</code>;
if <code>x &lt; 0</code>, <code>atan2(y, x) = sign(y)*(Pi - atan(abs(y/x)))</code>,
thus a number from <em class='math'>-Pi</em> to <em class='math'>Pi</em>.
As for <code>atan</code>, in case the exact mathematical result is <em class='math'>+Pi</em> or
<em class='math'>-Pi</em>,
its rounded result might be outside the function output range.
</p>
<p><code>atan2(y, 0)</code> does not raise any floating-point exception.
Special values are handled as described in the ISO C99 and IEEE&nbsp;754-2008
standards for the <code>atan2</code> function:
</p><ul>
<li> <code>atan2(+0, -0)</code> returns <em class='math'>+Pi</em>.
</li><li> <code>atan2(-0, -0)</code> returns <em class='math'>-Pi</em>.
</li><li> <code>atan2(+0, +0)</code> returns +0.
</li><li> <code>atan2(-0, +0)</code> returns −0.
</li><li> <code>atan2(+0, x)</code> returns <em class='math'>+Pi</em> for <em class='math'>x &lt; 0</em>.
</li><li> <code>atan2(-0, x)</code> returns <em class='math'>-Pi</em> for <em class='math'>x &lt; 0</em>.
</li><li> <code>atan2(+0, x)</code> returns +0 for <em class='math'>x &gt; 0</em>.
</li><li> <code>atan2(-0, x)</code> returns −0 for <em class='math'>x &gt; 0</em>.
</li><li> <code>atan2(y, 0)</code> returns <em class='math'>-Pi/2</em> for <em class='math'>y &lt; 0</em>.
</li><li> <code>atan2(y, 0)</code> returns <em class='math'>+Pi/2</em> for <em class='math'>y &gt; 0</em>.
</li><li> <code>atan2(+Inf, -Inf)</code> returns <em class='math'>+3*Pi/4</em>.
</li><li> <code>atan2(-Inf, -Inf)</code> returns <em class='math'>-3*Pi/4</em>.
</li><li> <code>atan2(+Inf, +Inf)</code> returns <em class='math'>+Pi/4</em>.
</li><li> <code>atan2(-Inf, +Inf)</code> returns <em class='math'>-Pi/4</em>.
</li><li> <code>atan2(+Inf, x)</code> returns <em class='math'>+Pi/2</em> for finite <em class='math'>x</em>.
</li><li> <code>atan2(-Inf, x)</code> returns <em class='math'>-Pi/2</em> for finite <em class='math'>x</em>.
</li><li> <code>atan2(y, -Inf)</code> returns <em class='math'>+Pi</em> for finite <em class='math'>y &gt; 0</em>.
</li><li> <code>atan2(y, -Inf)</code> returns <em class='math'>-Pi</em> for finite <em class='math'>y &lt; 0</em>.
</li><li> <code>atan2(y, +Inf)</code> returns +0 for finite <em class='math'>y &gt; 0</em>.
</li><li> <code>atan2(y, +Inf)</code> returns −0 for finite <em class='math'>y &lt; 0</em>.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-mpfr_005fcosh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_cosh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcosh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsinh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sinh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsinh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ftanh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_tanh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ftanh' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the hyperbolic cosine, sine or tangent of <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsinh_005fcosh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sinh_cosh</strong> <em>(mpfr_t <var>sop</var>, mpfr_t <var>cop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsinh_005fcosh' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set simultaneously <var>sop</var> to the hyperbolic sine of <var>op</var> and
<var>cop</var> to the hyperbolic cosine of <var>op</var>,
rounded in the direction <var>rnd</var> with the corresponding precision of
<var>sop</var> and <var>cop</var>, which must be different variables.
Return 0 iff both results are exact (see <code>mpfr_sin_cos</code> for a more
detailed description of the return value).
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsech"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sech</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsech' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fcsch"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_csch</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcsch' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fcoth"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_coth</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcoth' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the hyperbolic secant of <var>op</var>, cosecant of <var>op</var>,
cotangent of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005facosh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_acosh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005facosh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fasinh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_asinh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fasinh' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fatanh"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_atanh</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fatanh' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the inverse hyperbolic cosine, sine or tangent of <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005feint"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_eint</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005feint' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the exponential integral of <var>op</var>,
rounded in the direction <var>rnd</var>.
This is the sum of Euler&rsquo;s constant, of the logarithm
of the absolute value of <var>op</var>, and of the sum for k from 1 to infinity of
<var>op</var> to the power k, divided by k and factorial(k).
For positive <var>op</var>, it corresponds to the Ei function at <var>op</var>
(see formula 5.1.10 from the Handbook of Mathematical Functions from
Abramowitz and Stegun),
and for negative <var>op</var>, to the opposite of the
E1 function (sometimes called eint1)
at −<var>op</var> (formula 5.1.1 from the same reference).
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fli2"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_li2</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fli2' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to real part of the dilogarithm of <var>op</var>, rounded in the
direction <var>rnd</var>. MPFR defines the dilogarithm function as
<em class='math'>the integral of -log(1-t)/t from 0
to <var>op</var></em>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fgamma"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_gamma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fgamma' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fgamma_005finc"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_gamma_inc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fgamma_005finc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the Gamma function on <var>op</var>, resp. the
incomplete Gamma function on <var>op</var> and <var>op2</var>,
rounded in the direction <var>rnd</var>.
(In the literature, <code>mpfr_gamma_inc</code> is called upper
incomplete Gamma function,
or sometimes complementary incomplete Gamma function.)
For <code>mpfr_gamma</code> (and <code>mpfr_gamma_inc</code> when <var>op2</var> is zero),
when <var>op</var> is a negative integer, <var>rop</var> is set to NaN.
</p>
<p>Note: the current implementation of <code>mpfr_gamma_inc</code> is slow for
large values of <var>rop</var> or <var>op</var>, in which case some internal overflow
might also occur.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005flngamma"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_lngamma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flngamma' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the logarithm of the Gamma function on <var>op</var>,
rounded in the direction <var>rnd</var>.
When <var>op</var> is 1 or 2, set <var>rop</var> to +0 (in all rounding modes).
When <var>op</var> is an infinity or a nonpositive integer, set <var>rop</var> to +Inf,
following the general rules on special values.
When <em class='math'>−2<var>k</var>−1 &lt; <var>op</var> &lt; −2<var>k</var></em>,
<var>k</var> being a nonnegative integer, set <var>rop</var> to NaN.
See also <code>mpfr_lgamma</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005flgamma"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_lgamma</strong> <em>(mpfr_t <var>rop</var>, int *<var>signp</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005flgamma' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the logarithm of the absolute value of the
Gamma function on <var>op</var>, rounded in the direction <var>rnd</var>. The sign
(1 or −1) of Gamma(<var>op</var>) is returned in the object pointed to
by <var>signp</var>.
When <var>op</var> is 1 or 2, set <var>rop</var> to +0 (in all rounding modes).
When <var>op</var> is an infinity or a nonpositive integer, set <var>rop</var> to +Inf.
When <var>op</var> is NaN, −Inf or a negative integer, *<var>signp</var> is
undefined, and when <var>op</var> is ±0, *<var>signp</var> is the sign of the zero.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fdigamma"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_digamma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdigamma' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the Digamma (sometimes also called Psi)
function on <var>op</var>, rounded in the direction <var>rnd</var>.
When <var>op</var> is a negative integer, set <var>rop</var> to NaN.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fbeta"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_beta</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fbeta' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the Beta function at arguments <var>op1</var> and
<var>op2</var>.
Note: the current code does not try to avoid internal overflow or underflow,
and might use a huge internal precision in some cases.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fzeta"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_zeta</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fzeta' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fzeta_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_zeta_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fzeta_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the Riemann Zeta function on <var>op</var>,
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ferf"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_erf</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ferf' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ferfc"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_erfc</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ferfc' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the error function on <var>op</var>
(resp. the complementary error function on <var>op</var>)
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fj0"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_j0</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fj0' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fj1"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_j1</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fj1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fjn"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_jn</strong> <em>(mpfr_t <var>rop</var>, long <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fjn' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the first kind Bessel function of order 0,
(resp. 1 and <var>n</var>)
on <var>op</var>, rounded in the direction <var>rnd</var>. When <var>op</var> is
NaN, <var>rop</var> is always set to NaN. When <var>op</var> is plus or minus Infinity,
<var>rop</var> is set to +0. When <var>op</var> is zero, and <var>n</var> is not zero,
<var>rop</var> is set to +0 or −0 depending on the parity and sign of <var>n</var>,
and the sign of <var>op</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fy0"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_y0</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fy0' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fy1"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_y1</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fy1' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fyn"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_yn</strong> <em>(mpfr_t <var>rop</var>, long <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fyn' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the second kind Bessel function of order 0
(resp. 1 and <var>n</var>)
on <var>op</var>, rounded in the direction <var>rnd</var>. When <var>op</var> is
NaN or negative, <var>rop</var> is always set to NaN. When <var>op</var> is +Inf,
<var>rop</var> is set to +0. When <var>op</var> is zero, <var>rop</var> is set to +Inf
or −Inf depending on the parity and sign of <var>n</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fagm"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_agm</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fagm' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the arithmetic-geometric mean of <var>op1</var> and <var>op2</var>,
rounded in the direction <var>rnd</var>.
The arithmetic-geometric mean is the common limit of the sequences
<em class='math'><var>u</var>_<var>n</var></em> and <em class='math'><var>v</var>_<var>n</var></em>,
where <em class='math'><var>u</var>_<var>0</var></em>=<var>op1</var>, <em class='math'><var>v</var>_<var>0</var></em>=<var>op2</var>,
<em class='math'><var>u</var>_(<var>n</var>+1)</em> is the
arithmetic mean of <em class='math'><var>u</var>_<var>n</var></em> and <em class='math'><var>v</var>_<var>n</var></em>,
and <em class='math'><var>v</var>_(<var>n</var>+1)</em> is the geometric mean of
<em class='math'><var>u</var>_<var>n</var></em> and <em class='math'><var>v</var>_<var>n</var></em>.
If any operand is negative and the other one is not zero,
set <var>rop</var> to NaN.
If any operand is zero and the other one is finite (resp. infinite),
set <var>rop</var> to +0 (resp. NaN).
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fai"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_ai</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>x</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fai' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the value of the Airy function Ai
 on <var>x</var>, rounded in the direction <var>rnd</var>.
When <var>x</var> is
NaN,
<var>rop</var> is always set to NaN. When <var>x</var> is +Inf or −Inf,
<var>rop</var> is +0.
The current implementation is not intended to be used with large arguments.
It works with abs(<var>x</var>) typically smaller than 500. For larger arguments,
other methods should be used and will be implemented in a future version.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fconst_005flog2"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_const_log2</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fconst_005flog2' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fconst_005fpi"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_const_pi</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fconst_005fpi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fconst_005feuler"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_const_euler</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fconst_005feuler' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fconst_005fcatalan"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_const_catalan</strong> <em>(mpfr_t <var>rop</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fconst_005fcatalan' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the logarithm of 2, the value of <em class='math'>Pi</em>,
of Euler&rsquo;s constant 0.577&hellip;, of Catalan&rsquo;s constant 0.915&hellip;,
respectively, rounded in the direction
<var>rnd</var>. These functions cache the computed values to avoid other
calculations if a lower or equal precision is requested. To free these caches,
use <code>mpfr_free_cache</code> or <code>mpfr_free_cache2</code>.
</p></dd></dl>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Input-and-Output-Functions.html">Input and Output Functions</a>, Previous: <a href="Comparison-Functions.html">Comparison Functions</a>, Up: <a href="MPFR-Interface.html">MPFR Interface</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
