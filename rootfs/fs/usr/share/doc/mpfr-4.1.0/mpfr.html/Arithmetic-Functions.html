<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.1.0.

Copyright 1991, 1993-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in GNU Free Documentation License. -->
<title>Arithmetic Functions (GNU MPFR 4.1.0)</title>

<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 4.1.0.">
<meta name="keywords" content="Arithmetic Functions (GNU MPFR 4.1.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="MPFR-Interface.html" rel="up" title="MPFR Interface">
<link href="Comparison-Functions.html" rel="next" title="Comparison Functions">
<link href="Conversion-Functions.html" rel="prev" title="Conversion Functions">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Arithmetic-Functions">
<div class="header">
<p>
Next: <a href="Comparison-Functions.html" accesskey="n" rel="next">Comparison Functions</a>, Previous: <a href="Conversion-Functions.html" accesskey="p" rel="prev">Conversion Functions</a>, Up: <a href="MPFR-Interface.html" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="index-Arithmetic-functions"></span>
<span id="Arithmetic-Functions-1"></span><h3 class="section">5.5 Arithmetic Functions</h3>

<dl class="def">
<dt id="index-mpfr_005fadd"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_add</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fadd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fadd_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_add_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fadd_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fadd_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_add_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fadd_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fadd_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_add_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fadd_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fadd_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_add_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fadd_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fadd_005fq"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_add_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fadd_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var> + <var>op2</var></em> rounded in the direction
<var>rnd</var>.  The IEEE&nbsp;754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0) + 0 = (+0) and (−0) + 0 = (−0)).
The <code>mpfr_add_d</code> function assumes that the radix of the <code>double</code> type
is a power of 2, with a precision at most that declared by the C implementation
(macro <code>IEEE_DBL_MANT_DIG</code>, and if not defined 53 bits).
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sub</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fui_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_ui_sub</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fui_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsub_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sub_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsub_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsi_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_si_sub</strong> <em>(mpfr_t <var>rop</var>, long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsi_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsub_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sub_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsub_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fd_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_d_sub</strong> <em>(mpfr_t <var>rop</var>, double <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fd_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsub_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sub_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsub_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fz_005fsub"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_z_sub</strong> <em>(mpfr_t <var>rop</var>, mpz_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fz_005fsub' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsub_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sub_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsub_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsub_005fq"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sub_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsub_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var> - <var>op2</var></em> rounded in the direction
<var>rnd</var>.  The IEEE&nbsp;754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0) − 0 = (+0), (−0) − 0 = (−0),
0 − (+0) = (−0) and 0 − (−0) = (+0)).
The same restrictions than for <code>mpfr_add_d</code> apply to <code>mpfr_d_sub</code>
and <code>mpfr_sub_d</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fmul"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fmul_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fmul_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fmul_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fmul_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fmul_005fq"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var> times <var>op2</var></em> rounded in the
direction <var>rnd</var>.
When a result is zero, its sign is the product of the signs of the operands
(for types having no signed zeros, 0 is considered positive).
The same restrictions than for <code>mpfr_add_d</code> apply to <code>mpfr_mul_d</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsqr"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sqr</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsqr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>the square of <var>op</var></em>
rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fui_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_ui_div</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fui_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fdiv_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsi_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_si_div</strong> <em>(mpfr_t <var>rop</var>, long int <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsi_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fdiv_005fsi"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fd_005fdiv"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_d_div</strong> <em>(mpfr_t <var>rop</var>, double <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fd_005fdiv' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fdiv_005fd"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_d</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, double <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fdiv_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_z</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpz_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fdiv_005fq"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_q</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpq_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var>/<var>op2</var></em> rounded in the direction <var>rnd</var>.
When a result is zero, its sign is the product of the signs of the operands.
For types having no signed zeros, 0 is considered positive; but note that if
<var>op1</var> is non-zero and <var>op2</var> is zero, the result might change from
±Inf to NaN in future MPFR versions if there is an opposite decision
on the IEEE&nbsp;754 side.
The same restrictions than for <code>mpfr_add_d</code> apply to <code>mpfr_d_div</code>
and <code>mpfr_div_d</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsqrt"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sqrt</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsqrt' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fsqrt_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sqrt_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsqrt_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>the square root of <var>op</var></em>
rounded in the direction <var>rnd</var>.  Set <var>rop</var> to −0 if
<var>op</var> is −0, to be consistent with the IEEE&nbsp;754 standard.
Set <var>rop</var> to NaN if <var>op</var> is negative.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005frec_005fsqrt"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_rec_sqrt</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005frec_005fsqrt' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>the reciprocal square root of <var>op</var></em>
rounded in the direction <var>rnd</var>.  Set <var>rop</var> to +Inf if <var>op</var> is
±0, +0 if <var>op</var> is +Inf, and NaN if <var>op</var> is negative.  Warning!
Therefore the result on −0 is different from the one of the rSqrt
function recommended by the IEEE&nbsp;754-2008 standard (Section&nbsp;9.2.1),
which is −Inf instead of +Inf.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fcbrt"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_cbrt</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fcbrt' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005frootn_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_rootn_ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, unsigned long int <var>n</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005frootn_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the <var>n</var>th root (with <em class='math'><var>n</var> = 3</em>, the cubic root,
for <code>mpfr_cbrt</code>) of <var>op</var> rounded in the direction <var>rnd</var>.
For <em class='math'><var>n</var> = 0</em>, set <var>rop</var> to NaN.
For <var>n</var> odd (resp. even) and <var>op</var> negative (including −Inf),
set <var>rop</var> to a negative number (resp. NaN).
If <var>op</var> is zero, set <var>rop</var> to zero with the sign obtained by the
usual limit rules, i.e., the same sign as <var>op</var> if <var>n</var> is odd, and
positive if <var>n</var> is even.
</p>
<p>These functions agree with the rootn function of the IEEE&nbsp;754-2008
standard and the P754/D2.41 draft of the next standard (Section&nbsp;9.2).
Note that it is here restricted to <em class='math'><var>n</var> &gt;= 0</em>. Functions
allowing a negative <var>n</var> may be implemented in the future.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005froot"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_root</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, unsigned long int <var>n</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005froot' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>This function is the same as <code>mpfr_rootn_ui</code> except when <var>op</var>
is −0 and <var>n</var> is even: the result is −0 instead of +0
(the reason was to be consistent with <code>mpfr_sqrt</code>). Said otherwise,
if <var>op</var> is zero, set <var>rop</var> to <var>op</var>.
</p>
<p>This function predates the IEEE&nbsp;754-2008 standard and behaves differently
from its rootn function. It is marked as deprecated and will be removed in
a future release.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fneg"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_neg</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fneg' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fabs"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_abs</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fabs' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>-<var>op</var></em> and the absolute value of <var>op</var>
respectively, rounded in the direction <var>rnd</var>.
Just changes or adjusts
the sign if <var>rop</var> and <var>op</var> are the same variable,
otherwise a rounding might occur if the precision of <var>rop</var> is less than
that of <var>op</var>.
</p>
<p>The sign rule also applies to NaN in order to mimic the IEEE&nbsp;754
<code>negate</code> and <code>abs</code> operations, i.e., for <code>mpfr_neg</code>, the
sign is reversed, and for <code>mpfr_abs</code>, the sign is set to positive.
But contrary to IEEE&nbsp;754, the NaN flag is set as usual.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fdim"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_dim</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdim' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the positive difference of <var>op1</var> and <var>op2</var>, i.e.,
<em class='math'><var>op1</var> - <var>op2</var></em> rounded in the direction <var>rnd</var>
if <em class='math'><var>op1</var> &gt; <var>op2</var></em>, +0 if <em class='math'><var>op1</var> &lt;= <var>op2</var></em>,
and NaN if <var>op1</var> or <var>op2</var> is NaN.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fmul_005f2ui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_2ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fmul_005f2si"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_mul_2si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fmul_005f2si' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var> times 2 raised
to <var>op2</var></em>
rounded in the direction <var>rnd</var>. Just increases the exponent by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fdiv_005f2ui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_2ui</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, unsigned long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005f2ui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fdiv_005f2si"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_div_2si</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, long int <var>op2</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdiv_005f2si' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'><var>op1</var> divided by 2 raised
to <var>op2</var></em>
rounded in the direction <var>rnd</var>. Just decreases the exponent by <var>op2</var>
when <var>rop</var> and <var>op1</var> are identical.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ffac_005fui"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fac_ui</strong> <em>(mpfr_t <var>rop</var>, unsigned long int  <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffac_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the factorial of <var>op</var>, rounded in the direction <var>rnd</var>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ffma"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffma' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffms"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fms</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffms' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>(<var>op1</var> times <var>op2</var>) + <var>op3</var></em>
(resp. <em class='math'>(<var>op1</var> times <var>op2</var>) - <var>op3</var></em>)
rounded in the direction <var>rnd</var>.  Concerning special values (signed zeros,
infinities, NaN), these functions behave like a multiplication followed by a
separate addition or subtraction.  That is, the fused operation matters only
for rounding.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ffmma"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fmma</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_t <var>op4</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffmma' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffmms"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fmms</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>op1</var>, mpfr_t <var>op2</var>, mpfr_t <var>op3</var>, mpfr_t <var>op4</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffmms' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to <em class='math'>(<var>op1</var> times <var>op2</var>) + (<var>op3</var> times <var>op4</var>)</em>
(resp. <em class='math'>(<var>op1</var> times <var>op2</var>) - (<var>op3</var> times <var>op4</var>)</em>)
rounded in the direction <var>rnd</var>.
In case the computation of <em class='math'><var>op1</var> times <var>op2</var></em> overflows or
underflows (or that of <em class='math'><var>op3</var> times <var>op4</var></em>), the result
<var>rop</var> is computed as if the two intermediate products were computed with
rounding toward zero.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fhypot"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_hypot</strong> <em>(mpfr_t <var>rop</var>, mpfr_t <var>x</var>, mpfr_t <var>y</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fhypot' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the Euclidean norm of <var>x</var> and <var>y</var>,
i.e., the square root of the sum of the squares of <var>x</var> and <var>y</var>,
rounded in the direction <var>rnd</var>.
Special values are handled as described in the ISO C99 (Section&nbsp;F.9.4.3)
and IEEE&nbsp;754-2008 (Section&nbsp;9.2.1) standards:
If <var>x</var> or <var>y</var> is an infinity, then +Inf is returned in <var>rop</var>,
even if the other number is NaN.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fsum"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_sum</strong> <em>(mpfr_t <var>rop</var>, const mpfr_ptr <var>tab</var>[], unsigned long int <var>n</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fsum' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the sum of all elements of <var>tab</var>, whose size is <var>n</var>,
correctly rounded in the direction <var>rnd</var>. Warning: for efficiency reasons,
<var>tab</var> is an array of pointers
to <code>mpfr_t</code>, not an array of <code>mpfr_t</code>.
If <var>n</var> = 0, then the result is +0, and if <var>n</var> = 1, then the function
is equivalent to <code>mpfr_set</code>.
For the special exact cases, the result is the same as the one obtained
with a succession of additions (<code>mpfr_add</code>) in infinite precision.
In particular, if the result is an exact zero and <em class='math'><var>n</var> &gt;= 1</em>:
</p><ul>
<li> if all the inputs have the same sign (i.e., all +0 or all −0),
then the result has the same sign as the inputs;
</li><li> otherwise, either because all inputs are zeros with at least a +0 and
a −0, or because some inputs are non-zero (but they globally cancel),
the result is +0, except for the <code>MPFR_RNDD</code> rounding mode, where it is
−0.
</li></ul>
</dd></dl>

<dl class="def">
<dt id="index-mpfr_005fdot"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_dot</strong> <em>(mpfr_t <var>rop</var>, const mpfr_ptr <var>a</var>[], const mpfr_ptr <var>b</var>[], unsigned long int <var>n</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fdot' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>rop</var> to the dot product of elements of <var>a</var> by those of <var>b</var>,
whose common size is <var>n</var>,
correctly rounded in the direction <var>rnd</var>. Warning: for efficiency reasons,
<var>a</var> and <var>b</var> are arrays of pointers to <code>mpfr_t</code>.
This function is experimental, and does not yet handle intermediate overflows
and underflows.
</p></dd></dl>

<p>For the power functions (with an integer exponent or not), see <a href="Transcendental-Functions.html#mpfr_005fpow">mpfr_pow</a>
in <a href="Transcendental-Functions.html">Transcendental Functions</a>.
</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Comparison-Functions.html">Comparison Functions</a>, Previous: <a href="Conversion-Functions.html">Conversion Functions</a>, Up: <a href="MPFR-Interface.html">MPFR Interface</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
