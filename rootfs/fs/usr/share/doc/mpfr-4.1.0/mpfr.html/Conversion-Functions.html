<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.1.0.

Copyright 1991, 1993-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in GNU Free Documentation License. -->
<title>Conversion Functions (GNU MPFR 4.1.0)</title>

<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 4.1.0.">
<meta name="keywords" content="Conversion Functions (GNU MPFR 4.1.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="MPFR-Interface.html" rel="up" title="MPFR Interface">
<link href="Arithmetic-Functions.html" rel="next" title="Arithmetic Functions">
<link href="Combined-Initialization-and-Assignment-Functions.html" rel="prev" title="Combined Initialization and Assignment Functions">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<div class="section" id="Conversion-Functions">
<div class="header">
<p>
Next: <a href="Arithmetic-Functions.html" accesskey="n" rel="next">Arithmetic Functions</a>, Previous: <a href="Combined-Initialization-and-Assignment-Functions.html" accesskey="p" rel="prev">Combined Initialization and Assignment Functions</a>, Up: <a href="MPFR-Interface.html" accesskey="u" rel="up">MPFR Interface</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="index-Conversion-functions"></span>
<span id="Conversion-Functions-1"></span><h3 class="section">5.4 Conversion Functions</h3>

<dl class="def">
<dt id="index-mpfr_005fget_005fflt"><span class="category">Function: </span><span><em>float</em> <strong>mpfr_get_flt</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fflt' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fd"><span class="category">Function: </span><span><em>double</em> <strong>mpfr_get_d</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fd' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fld"><span class="category">Function: </span><span><em>long double</em> <strong>mpfr_get_ld</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fld' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005ffloat128"><span class="category">Function: </span><span><em>_Float128</em> <strong>mpfr_get_float128</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005ffloat128' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fdecimal64"><span class="category">Function: </span><span><em>_Decimal64</em> <strong>mpfr_get_decimal64</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fdecimal64' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fdecimal128"><span class="category">Function: </span><span><em>_Decimal128</em> <strong>mpfr_get_decimal128</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fdecimal128' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a <code>float</code> (respectively <code>double</code>,
<code>long double</code>, <code>_Decimal64</code>, or <code>_Decimal128</code>)
using the rounding mode <var>rnd</var>.
If <var>op</var> is NaN, some fixed NaN (either quiet or signaling) or the result
of 0.0/0.0 is returned. If <var>op</var> is ±Inf, an infinity of the same
sign or the result of ±1.0/0.0 is returned. If <var>op</var> is zero, these
functions return a zero, trying to preserve its sign, if possible.
The <code>mpfr_get_float128</code>, <code>mpfr_get_decimal64</code> and
<code>mpfr_get_decimal128</code> functions are built
only under some conditions: see the documentation of <code>mpfr_set_float128</code>,
<code>mpfr_set_decimal64</code> and <code>mpfr_set_decimal128</code> respectively.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fget_005fsi"><span class="category">Function: </span><span><em>long</em> <strong>mpfr_get_si</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fsi' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fui"><span class="category">Function: </span><span><em>unsigned long</em> <strong>mpfr_get_ui</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fui' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fsj"><span class="category">Function: </span><span><em>intmax_t</em> <strong>mpfr_get_sj</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fsj' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fuj"><span class="category">Function: </span><span><em>uintmax_t</em> <strong>mpfr_get_uj</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fuj' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a <code>long</code>, an <code>unsigned long</code>,
an <code>intmax_t</code> or an <code>uintmax_t</code> (respectively) after rounding
it to an integer with respect to <var>rnd</var>.
If <var>op</var> is NaN, 0 is returned and the <em>erange</em> flag is set.
If <var>op</var> is too big for the return type, the function returns the maximum
or the minimum of the corresponding C type, depending on the direction
of the overflow; the <em>erange</em> flag is set too.
When there is no such range error, if the return value differs from
<var>op</var>, i.e., if <var>op</var> is not an integer, the inexact flag is set.
See also <code>mpfr_fits_slong_p</code>, <code>mpfr_fits_ulong_p</code>,
<code>mpfr_fits_intmax_p</code> and <code>mpfr_fits_uintmax_p</code>.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fget_005fd_005f2exp"><span class="category">Function: </span><span><em>double</em> <strong>mpfr_get_d_2exp</strong> <em>(long *<var>exp</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fd_005f2exp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005fget_005fld_005f2exp"><span class="category">Function: </span><span><em>long double</em> <strong>mpfr_get_ld_2exp</strong> <em>(long *<var>exp</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fld_005f2exp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return <var>d</var> and set <var>exp</var>
(formally, the value pointed to by <var>exp</var>)
such that <em class='math'>0.5&lt;=abs(<var>d</var>)&lt;1</em>
and <em class='math'><var>d</var> times 2 raised to <var>exp</var></em> equals
<var>op</var> rounded to double (resp. long double)
precision, using the given rounding mode.
If <var>op</var> is zero, then a zero of the same sign (or an unsigned zero,
if the implementation does not have signed zeros) is returned, and
<var>exp</var> is set to 0.
If <var>op</var> is NaN or an infinity, then the corresponding double precision
(resp. long-double precision)
value is returned, and <var>exp</var> is undefined.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ffrexp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_frexp</strong> <em>(mpfr_exp_t *<var>exp</var>, mpfr_t <var>y</var>, mpfr_t <var>x</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffrexp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Set <var>exp</var>
(formally, the value pointed to by <var>exp</var>) and <var>y</var>
such that <em class='math'>0.5&lt;=abs(<var>y</var>)&lt;1</em>
and <em class='math'><var>y</var> times 2 raised to <var>exp</var></em> equals
<var>x</var> rounded to the precision of <var>y</var>, using the given rounding mode.
If <var>x</var> is zero, then <var>y</var> is set to a zero of the same sign and
<var>exp</var> is set to 0.
If <var>x</var> is NaN or an infinity, then <var>y</var> is set to the same value
and <var>exp</var> is undefined.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fget_005fz_005f2exp"><span class="category">Function: </span><span><em>mpfr_exp_t</em> <strong>mpfr_get_z_2exp</strong> <em>(mpz_t <var>rop</var>, mpfr_t <var>op</var>)</em><a href='#index-mpfr_005fget_005fz_005f2exp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Put the scaled significand of <var>op</var> (regarded as an integer, with the
precision of <var>op</var>) into <var>rop</var>, and return the exponent <var>exp</var>
(which may be outside the current exponent range) such that <var>op</var>
exactly equals
<var>rop</var> times 2 raised to the power <var>exp</var>.
If <var>op</var> is zero, the minimal exponent <code>emin</code> is returned.
If <var>op</var> is NaN or an infinity, the <em>erange</em> flag is set, <var>rop</var>
is set to 0, and the the minimal exponent <code>emin</code> is returned.
The returned exponent may be less than the minimal exponent <code>emin</code>
of MPFR numbers in the current exponent range; in case the exponent is
not representable in the <code>mpfr_exp_t</code> type, the <em>erange</em> flag
is set and the minimal value of the <code>mpfr_exp_t</code> type is returned.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fget_005fz"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_get_z</strong> <em>(mpz_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fz' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a <code>mpz_t</code>, after rounding it with respect to
<var>rnd</var>. If <var>op</var> is NaN or an infinity, the <em>erange</em> flag is
set, <var>rop</var> is set to 0, and 0 is returned. Otherwise the return
value is zero when <var>rop</var> is equal to <var>op</var> (i.e., when <var>op</var>
is an integer), positive when it is greater than <var>op</var>, and negative
when it is smaller than <var>op</var>; moreover, if <var>rop</var> differs from
<var>op</var>, i.e., if <var>op</var> is not an integer, the inexact flag is set.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fget_005fq"><span class="category">Function: </span><span><em>void</em> <strong>mpfr_get_q</strong> <em>(mpq_t <var>rop</var>, mpfr_t <var>op</var>)</em><a href='#index-mpfr_005fget_005fq' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a <code>mpq_t</code>.
If <var>op</var> is NaN or an infinity, the <em>erange</em> flag is
set and <var>rop</var> is set to 0. Otherwise the conversion is always exact.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005fget_005ff"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_get_f</strong> <em>(mpf_t <var>rop</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005ff' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a <code>mpf_t</code>, after rounding it with respect to
<var>rnd</var>.
The <em>erange</em> flag is set if <var>op</var> is NaN or an infinity, which
do not exist in MPF.  If <var>op</var> is NaN, then <var>rop</var> is undefined.
If <var>op</var> is +Inf (resp. −Inf), then <var>rop</var> is set to
the maximum (resp. minimum) value in the precision of the MPF number;
if a future MPF version supports infinities, this behavior will be
considered incorrect and will change (portable programs should assume
that <var>rop</var> is set either to this finite number or to an infinite
number).
Note that since MPFR currently has the same exponent type as MPF (but
not with the same radix), the range of values is much larger in MPF
than in MPFR, so that an overflow or underflow is not possible.
</p></dd></dl>

<span id="mpfr_005fget_005fstr_005fndigits"></span><dl class="def">
<dt id="index-mpfr_005fget_005fstr_005fndigits"><span class="category">Function: </span><span><em>size_t</em> <strong>mpfr_get_str_ndigits</strong> <em>(int <var>b</var>, mpfr_prec_t <var>p</var>)</em><a href='#index-mpfr_005fget_005fstr_005fndigits' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return the minimal integer <em class='math'>m</em> such that any number
of <var>p</var> bits, when output with <em class='math'>m</em> digits in radix <var>b</var> with
rounding to nearest, can be recovered exactly when read again,
still with rounding to nearest.
More precisely, we have
m = 1 + ceil(<var>p</var>*log(2)/log(<var>b</var>)),
with <var>p</var> replaced by <var>p</var>−1 if <var>b</var> is a power of 2.
</p>
<p>The argument <var>b</var> must be in the range 2 to 62; this is the range of bases
supported by the <code>mpfr_get_str</code> function. Note that contrary to the base
argument of this function, negative values are not accepted.
</p></dd></dl>

<span id="mpfr_005fget_005fstr"></span><dl class="def">
<dt id="index-mpfr_005fget_005fstr"><span class="category">Function: </span><span><em>char *</em> <strong>mpfr_get_str</strong> <em>(char *<var>str</var>, mpfr_exp_t *<var>expptr</var>, int <var>base</var>, size_t <var>n</var>, mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005fget_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Convert <var>op</var> to a string of digits in base abs(<var>base</var>),
with rounding in the direction <var>rnd</var>, where <var>n</var> is either zero
(see below) or the number of significant digits output in the string.
The argument <var>base</var> may vary from 2 to 62 or from −2 to −36;
otherwise the function does nothing and immediately returns a null pointer.
</p>
<p>For <var>base</var> in the range 2 to 36, digits and lower-case letters are used;
for −2 to −36, digits and upper-case letters are used; for
37 to 62, digits, upper-case letters, and lower-case letters, in that
significance order, are used. Warning! This implies that for
<em class='math'><var>base</var> &gt; 10</em>, the successor of the digit 9 depends on <var>base</var>.
This choice has been done for compatibility with GMP&rsquo;s <code>mpf_get_str</code>
function. Users who wish a more consistent behavior should write a simple
wrapper.
</p>
<p>If the input is NaN, then the returned string is &lsquo;<samp>@NaN@</samp>&rsquo; and the
NaN flag is set. If the input is +Inf (resp. −Inf), then the
returned string is &lsquo;<samp>@Inf@</samp>&rsquo; (resp. &lsquo;<samp>-@Inf@</samp>&rsquo;).
</p>
<p>If the input number is a finite number, the exponent is written through
the pointer <var>expptr</var> (for input 0, the current minimal exponent is
written); the type <code>mpfr_exp_t</code> is large enough to hold the exponent
in all cases.
</p>
<p>The generated string is a fraction, with an implicit radix point immediately
to the left of the first digit.  For example, the number −3.1416 would
be returned as &quot;−31416&quot; in the string and 1 written at <var>expptr</var>.
If <var>rnd</var> is to nearest, and <var>op</var> is exactly in the middle of two
consecutive possible outputs, the one with an even significand is chosen,
where both significands are considered with the exponent of <var>op</var>.
Note that for an odd base, this may not correspond to an even last digit:
for example with 2 digits in base 7, (14) and a half is rounded to (15)
which is 12 in decimal, (16) and a half is rounded to
(20) which is 14 in decimal,
and (26) and a half is rounded to (26) which is 20 in decimal.
</p>
<p>If <var>n</var> is zero, the number of digits of the significand is taken as
<code>mpfr_get_str_ndigits(<var>base</var>,<var>p</var>)</code> where <var>p</var> is the precision
of <var>op</var> (see <a href="#mpfr_005fget_005fstr_005fndigits">mpfr_get_str_ndigits</a>).
</p>
<p>If <var>str</var> is a null pointer, space for the significand is allocated using
the allocation function (see <a href="Memory-Handling.html">Memory Handling</a>) and a pointer to the string
is returned (unless the base is invalid).
To free the returned string, you must use <code>mpfr_free_str</code>.
</p>
<p>If <var>str</var> is not a null pointer, it should point to a block of storage
large enough for the significand. A safe block size (sufficient for any
value) is <code>max(<var>n</var> + 2, 7)</code> if <var>n</var> is not zero; if <var>n</var> is
zero, replace it by <code>mpfr_get_str_ndigits(<var>base</var>,<var>p</var>)</code> where
<var>p</var> is the precision of <var>op</var>, as mentioned above.
The extra two bytes are
for a possible minus sign, and for the terminating null character, and the
value 7 accounts for &lsquo;<samp>-@Inf@</samp>&rsquo; plus the terminating null character.
The pointer to the string <var>str</var> is returned (unless the base is invalid).
</p>
<p>Like in usual functions, the inexact flag is set iff the result is inexact.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ffree_005fstr"><span class="category">Function: </span><span><em>void</em> <strong>mpfr_free_str</strong> <em>(char *<var>str</var>)</em><a href='#index-mpfr_005ffree_005fstr' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Free a string allocated by <code>mpfr_get_str</code> using the unallocation
function (see <a href="Memory-Handling.html">Memory Handling</a>).
The block is assumed to be <code>strlen(<var>str</var>)+1</code> bytes.
</p></dd></dl>

<dl class="def">
<dt id="index-mpfr_005ffits_005fulong_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_ulong_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fulong_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fslong_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_slong_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fslong_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fuint_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_uint_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fuint_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fsint_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_sint_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fsint_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fushort_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_ushort_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fushort_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fsshort_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_sshort_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fsshort_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fuintmax_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_uintmax_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fuintmax_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dt id="index-mpfr_005ffits_005fintmax_005fp"><span class="category">Function: </span><span><em>int</em> <strong>mpfr_fits_intmax_p</strong> <em>(mpfr_t <var>op</var>, mpfr_rnd_t <var>rnd</var>)</em><a href='#index-mpfr_005ffits_005fintmax_005fp' class='copiable-anchor'> &para;</a></span></dt>
<dd><p>Return non-zero if <var>op</var> would fit in the respective C data type,
respectively <code>unsigned long</code>, <code>long</code>, <code>unsigned int</code>,
<code>int</code>, <code>unsigned short</code>, <code>short</code>, <code>uintmax_t</code>,
<code>intmax_t</code>, when rounded to an integer in the direction <var>rnd</var>.
For instance, with the <code>MPFR_RNDU</code> rounding mode on −0.5,
the result will be non-zero for all these functions.
For <code>MPFR_RNDF</code>, those functions return non-zero when it is guaranteed
that the corresponding conversion function (for example <code>mpfr_get_ui</code>
for <code>mpfr_fits_ulong_p</code>), when called with faithful rounding,
will always return a number that is representable in the corresponding type.
As a consequence, for <code>MPFR_RNDF</code>, <code>mpfr_fits_ulong_p</code> will return
non-zero for a non-negative number less than or equal to <code>ULONG_MAX</code>.
</p></dd></dl>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Arithmetic-Functions.html">Arithmetic Functions</a>, Previous: <a href="Combined-Initialization-and-Assignment-Functions.html">Combined Initialization and Assignment Functions</a>, Up: <a href="MPFR-Interface.html">MPFR Interface</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
